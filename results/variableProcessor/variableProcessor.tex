\documentclass{article}[11pt]
\usepackage[subtle]{savetrees}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{xcolor}

\newcommand{\defn}[1]{{\textit{\textbf{\boldmath #1}}}}
\renewcommand{\paragraph}[1]{\vspace{0.09in}\noindent{\bf \boldmath #1.}} 
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\text{Var}}
\DeclareMathOperator{\img}{Im}
\DeclareMathOperator{\polylog}{\text{polylog}}
\DeclareMathOperator{\poly}{\text{poly}}
\DeclareMathOperator{\st}{\text{ such that }}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\interior}[1]{%
  {\kern0pt#1}^{\mathrm{o}}%
}


\newcommand{\contr}[0]{\[ \Rightarrow\!\Leftarrow \]}
\newcommand{\defeq}{\vcentcolon=}
\newcommand{\eqdef}{=\vcentcolon}

\newtheorem{fact}{Fact}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}{Conjecture}

\title{An investigation of variable-processor cup games}
\author{Alek Westover}

\begin{document}
\maketitle

In the \defn{variable-processor cup game} the filler is allowed to change
$p$, the amount of water that the filler can add and the number of cups from
which the emptier can remove water.  Apriori this offers neither the filler nor the emptier a clear
advantage: lower values of $p$ mean that the emptier is at more of a
discretization advantage but also mean that the filler can anchor fewer cups.
We hoped that the variable-processor cup game could be simulated in the vanilla
multiprocessor cup game, because the extra ability given to the filler does not
seem very strong. The new version of the cup game arose as we tried to get a bound 
of $\Omega(\log p)$ backlog in the multiprocessor game against an off-line filler, 
which would combine with previous results to give us a lower bound that matches
out upper bound: $O(\log\log n + \log p)$. This new version seemed promising in
this respect because of the following Lemma:

\begin{lemma}
  \label{lem:dprand}
  In the variable-processor cup game on $n$ cups against an 
  off-line filler, the filler can force backlog to be $\Omega(\log p)$.
\end{lemma}

However, attempts at simulating the variable-processor cup game are futile
because of the following Lemmas, which shows that the variable-processor cup
game is, surprisingly, fundamentally different than the multiprocessor cup game,
and thus impossible to simulate:

\begin{lemma}
  \label{lem:dpdet}
  In the variable-processor cup game on $n$ cups against an online filler, the
  filler can force backlog to be $\Omega(\log^2 p)$.
\end{lemma}

In fact Lemma \ref{lem:dpdet} gives a fairly weak lowerbound on backlog; the
filler can achieve much higher fill, as high as $\poly(n)$, which follows as a
corollary of the \defn{Amplification Lemma:}

\begin{lemma}
  \label{lem:amplification}
  Given a filling algorithm for achieving $f(k)$ backlog on $k$ cups (this
  backlog is relative to a baseline of the average of the cups, with "negative
  fill"--fill below the average--allowed even in the initial state), there
  exists a filling algorithm for achieving ``amplified" backlog of
  $$f'(k) = \frac{1}{2}(f(k/2) + f(k/4) + \cdots )$$
  on $k$ cups.
\end{lemma}

We proceed to prove the Lemmas. 

\begin{proof}[Proof of Lemma \ref{lem:dprand}.]
  {\color{red} TODO: rigorify it}
  First we establish a useful subroutine that the filler will use: acquiring a
  ``tail" (a set of cups with fill at least some positive constant) of size
  $\Theta(p)$.
  The filler anchors $p-1$ cups and repeats the following algorithm for each anchored cup $i$:
  At every step the filler adds one water to each anchored cup. For $p^c$
  rounds the filler plays a single processor cup game on $20$ non-anchored cups
  that lasts for 19 steps. The filler's strategy will strongly disincentivise
  the emptier from not emptying from each of the $p-1$ anchor cups every time,
  so for simplicity we initially will neglect the possibility that the emptier
  removes from multiple cups in the $20$ cups. Over the $19$ steps the emptier
  will remove from $19$ cups. In the worst case these are all distinct members
  of the $20$ cups. We can predict this sequence with constant probability,
  specifically probability $1/20!$. At the end of each of these single
  processor cupgames the filler with probability $p^{c-1}$
  swaps the cup that has received $\frac{1}{20} + \frac{1}{19} + \cdots +
  \frac{1}{1} > \ln 20$ fill with constant probability with a random cup in the
  anchor set.  At the end of this process each cup in the anchor set has at
  least a $1/20!$ chance of having fill at least $\ln 20.$ The expectation of
  the number of cups that have fill at least $\ln 20$ is at least $(p-1)/20!$. 
  Using a Chernoff bound we can show that with high probability in $p$ the actual
  number of such cups does not deviate from this mean by more than a constant
  factor. In particular, let $m_A$ be the actual number of cups with fill at
  least $\ln 20$ in the anchor set, and let $m_E$ be the expected number (i.e.
  $m_E = (p-1)/20!$) of such cups in the anchor set. Then $$\Pr[m_A < m_E /2 ]
  \le e^{-p / (12\cdot 20!)}.$$

  The filler follows the following algorithm:
  \begin{enumerate}
    \item Get $\Theta(p)$ cups with fill at least $\ln 20$ 
    \item Decrease the number of processors from $p$ to $p' = (p-1)/(20!\cdot 2)$.
      Over the next $\lceil (\ln 20)/2 \rceil = 1$ steps the filler places $1$
      water in each of $p'$ cups. Assuming that the emptier is greedy then this
      will result in having fill $\lceil (\ln 20) /2 \rceil$ in those \emph{known} cups.
    \item Recurse on those known cups. {\color{red} seems problematic that we are playing against smoothed greedy, what if the smoothing kills stuff}
  \end{enumerate}
  The maximum recursion depth possible is $\Theta(\log p)$, hence we have a backlog guarantee of $\Omega(\log p)$
  as desired.
\end{proof}

\begin{proof}[Proof of Lemma \ref{lem:dpdet}.]
  {\color{red} TODO: rigorify it}
  An important subroutine is again the ability to achive a ``tail" of size
  $\Theta(p)$ with a specified fill.  This is achieved in a similar manner as
  in the proof of Lemma \ref{lem:dprand}.  The filler anchors $p-1$ cups, and
  then repeats the following algorithm for each anchored cup: At every step the
  filler adds one water to the anchored cups. For $p^c$ rounds the filler
  plays a single processor cup game on $1000p$ cups. If the emptier ever places
  at most 1 unit of water into the single processor cup game at each step then
  the filler swaps the cup which must have fill $\Omega(\log p)$ to the anchor
  set.  If the emptier has placed multiple units of water in the single
  processor cup game in each of the games, then the anchor set has gained a ton
  of water. For now, for simplicity, we assume that we are playing against a
  greedy emptier so that this does not happen. Of course if the emptier is
  determined to not let the backlog in a single cup increase then it can, but
  at great cost.  At the end of this process we have $p$ cups of fill
  $\Omega(p)$.  The filler then cuts $p$ in half, and recurses.
  Recursion depth is of course $\log p$, so this strategy gives backlog
  $\Omega(\log^2 p)$.

\end{proof}

Next we establish the Amplification Lemma:
\begin{proof}[Proof of Lemma \ref{lem:amplification}]
  The filler anchors $n/2$ cups. Then, the filler applies the algorithm to
  achieve backlog $f(n/2)$ on the $n/2$ non-anchored cups, and swaps the cups
  into the anchor set upon achieving this backlog. Note that this backlog is
  relative to the average fill in those cups, which is depressed by the process
  of siphoning water out of the non-anchored cups into the anchor set. In
  particular, say that the initial average fill was $\mu$, and that the final
  average fill in the non-anchor set is $\mu'$. The average fill in the anchor
  set is at least $\mu' + f(n/2)$. Hence the average fill of all the cups is at
  least $\mu' + f(n/2)/2$. But the average fill at the end of the process is
  the same as the average fill at the start of the process, so $\mu \ge \mu' +
  f(n/2)/2$. The fact that the non-anchor cups have sunk by at least $f(n/2)/2$
  implies that the anchor cups must have risen by at least this amount (on
  average) to maintain the average fill. Note that $f$ assumes negative water
  will be incurred for cups that go below the average, however in the real game
  there is a hard threshold at $0$, below which there is no negative water.
  This is not a problem; in fact it is benneficial for the filler! We can
  easily slightly revise the above argument to accomodate the fact that cups
  can zero out: Let the final average fill be $\mu+\epsilon$ for some
  $\epsilon>0$. We have $\mu+\epsilon \ge \mu' + f(n/2)/2$, so the average in the
  anchor cups must be at least $\mu+\epsilon+f(n/2)/2$ to achieve the correct
  average fill.
  
  Upon achieving fill $\frac{1}{2}f(n/2)$ in the $n/2$ anchor cups, the filler
  will cut the number of processors in half, and proceed to focus only on the cups that 
  formed the anchor set. By recursing with an identical method the filler can
  get backlog $\frac{1}{2}(f(n/2) + f(n/4) + f(n/8) + \cdots)$.

  % Note that the ability to increase $p$ is needed in the recursive calling of $f$.
\end{proof}

We now use the Amplication Lemma to achieve the following:
\begin{corollary}
  The filler can achieve backlog $\Omega(\poly(n))$
\end{corollary}
\begin{proof}
  We recursively construct functions $f_m$ by application of the Amplification
  Lemma. We will start with 
  $$f_0(k) = 
  \begin{cases} 
    \log_2 k, & k\geq 1, \\
    0 & \text{else.}
  \end{cases}$$
    We then construct $f_{m+1}$ as the
  \defn{amplification} of $f_m$.  
  By repeated application of this procedure $\log_2 n^{1/9}$ times we 
  achieve a function $f_{\log_2 \sqrt{n}}(k)$ with the property that for $k \geq n,$
  $f_{\log_2 n^{1/9}}(k) \geq 2^{\log_2 n^{1/9}} \log_2 k$. In particular, this gives a filling strategy 
  that when applied to $n$ cups gives backlog $\Omega(n^{1/9}\log_2 n) \ge \Omega(\poly(n))$ as desired.
  To prove this, we prove the following lowerbound for $f_m$ by induction:
  $$f_m(k) \geq 2^m \log_2 k, \text{ for } k \geq (2^9)^m.$$
  The base case follows from the definition of $f_0$. Assuming the property for $f_m$, we get the following:
  \begin{align}
    \text{for } k > (2^9)^{m+1}, f_{m+1}(k) &= \frac{1}{2}(f_m(k/2) + f_m(k/4) + \cdots + f_m(k/2^9) + \cdots)\\
  &\geq \frac{1}{2}(f_m(k/2) + f_m(k/4) + \cdots + f_m(k/2^9))\\
  &\geq \frac{1}{2}2^m(\log_2 (k/2) + \log_2(k/4) + \cdots + \log_2(k/2^9))\\
  &\geq \frac{1}{2}2^m(9\log_2 (k) - \frac{9 \cdot 10}{2}) \label{step:readydrop}\\
  &\geq 2^{m+1} \log_2(k) \label{step:dropped}
  \end{align}
  as desired. Hence the inductive claim holds, which establishes that $f_{\log_2
  n^{1/9}}$ satisfies the desried condition, which proves that backlog can be
  made $\tilde{\Omega}(n^{1/9})$.

  Generalizing this approach we can achieve a slightly better polynomial
  lowerbound on backlog.  In our construction the point after which we had a
  bound for $f_m$ grew further out by a factor of $2^9$ each time. Instead of
  $2^9$ we now use $2^\alpha$ for some $\alpha \in \mathbb{N}$, and can find a
  better value of $\alpha$.  The value of $\alpha$ dictates how many
  itterations we can perform: we can perform $\log_2 n^{1/\alpha}$ itterations.
  The parameter $\alpha$ also dictates the multiplicative factor that we gain
  upon going from $f_m$ to $f_{m+1}$. For $\alpha = 9$ this was $2$. In general
  it turns out to be $\frac{\alpha -1}{4}$.  Hence, we can achieve backlog
  $\Omega\left(\left(\frac{\alpha -1}{4}\right)^{\log_2 n^{1/\alpha}}\log_2
  n\right)$. This optimizes at $\alpha = 13$, to backlog
  $\Omega(n^{\frac{\log_2 3}{13}}\log n) \approx \Omega(n^{0.122}\log n)$. 
  We can actually even improve over this slightly. Note that in the proof that
  $f_{m+1}$ gains a factor of $2$ over $f_m$ given above, the transition from
  (\ref{step:readydrop}) to (\ref{step:dropped}) is usually very loose: for small
  $m$ a significant portion of the $\log_2 k$ is annihlated by the constant
  $1+2+\cdots+9$ (or in general $1+2+\cdots + \alpha$), but for larger values
  of $m$ because $k$ must be large we can get larger factors between steps, in
  theory factors arbitrarily close to $\alpha /2$. If we could gain a factor of
  $\alpha/2$ at each step, then the backlog achievable would be
  $\Omega((\alpha/2)^{\log_2{n^{1/\alpha}}}\log n)=
  \Omega(n^{(\log_2{\alpha/2})/2} \log n)$ which optimizes (over the naturals)
  at $\alpha = 5$ to $n^{(\log_2 5/2)/5} \approx n^{0.264}$.  However, we can't
  actually gain a factor of $\alpha/2$ each time because of the subtracted
  constant. But, for any $\epsilon >0$ we can achieve a $\alpha/2 - \epsilon$
  factor increase each time (for sufficiently large $m$).  Of course $\epsilon$
  can't be made arbitrarily small becasue $m$ can't be made arbitrarily large,
  and the "cut off" $m$ where we start achieving the $\alpha/2 - \epsilon$
  factor increase must be a constant (not dependent on $n$).  When the cutoff
  $m$, or equivalently $\epsilon$, is constant then we can achieve backlog
  $\Omega((\alpha/2 - \epsilon)^{\log_2{n^{1/\alpha}}}\log n)=
  \Omega(n^{(\log_2{\alpha/2 - \epsilon})/2} \log n)$.  For instance, with this
  method we can get backlog $\tilde{\Omega}(n^{1/4})$ for appropriate $\epsilon, \alpha$
  choice, or $\tilde{\Omega}(n^{(\log_2 5/2 - \epsilon)/5})$ for any constant $\epsilon >0$.
  We could potentially aim to achieve even higher backlog by using more than
  the first $\alpha$ terms of the sum. The terms after $f_m(k/2^\alpha)$ in the sum
  are evaluated at points where they are potentially positive, but will not
  have the full strength of the $2^m \log_2 k$. This makes them difficult to
  deal with, and as it is not likely that we will get anything besides a modest
  increase in the exponent of our polynomial we do not pursue this. 

\end{proof}

\begin{remark}
  The running time of this is XXX which is kinda big.
  {\color{red} TODO: do it}
\end{remark}


Becasue of the large backlog achievable by the on-line filler in the
variable-processor cup game, and the fact that the off-line filler can 
achieve a set of cups with known constant fill with failure probability
exponentially small in the variable-processor cup game, we conjectured that 
Lemma \ref{lem:dprand} can be improved to the following:
\begin{lemma}
  There exists an off-line filling strategy that achieves backlog
  $\Omega(2^{\sqrt{\log n}/2})$ with decent probability in time $O(n)$.
\end{lemma}
\begin{proof}
  {\color{red} TODO: do it}
  
\end{proof}

\end{document}

